# ğŸ” è®¤è¯ç³»ç»Ÿæ–‡æ¡£

NextAuth.js è®¤è¯å®ç°è¯¦è§£ã€‚

## ğŸ“‹ è®¤è¯æ¶æ„

ä½¿ç”¨ **NextAuth.js v4** å®ç°å®Œæ•´çš„è®¤è¯ç³»ç»Ÿã€‚

## ğŸ—ï¸ æ ¸å¿ƒç»„ä»¶

### 1. NextAuth é…ç½®

ä½ç½®ï¼š`src/lib/auth.ts`

```typescript
export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(prisma),

  providers: [
    CredentialsProvider({
      /* ... */
    }),
    GitHubProvider({
      /* ... */
    }), // å¯é€‰
  ],

  session: {
    strategy: 'jwt',
    maxAge: 30 * 24 * 60 * 60, // 30 å¤©
  },

  callbacks: {
    async jwt({ token, user }) {
      /* ... */
    },
    async session({ session, token }) {
      /* ... */
    },
  },
};
```

## ğŸ”‘ è®¤è¯æä¾›å•†

### Credentials Providerï¼ˆé‚®ç®±/å¯†ç ï¼‰

**å·¥ä½œæµç¨‹**ï¼š

1. ç”¨æˆ·æäº¤é‚®ç®±å’Œå¯†ç 
2. æŸ¥è¯¢æ•°æ®åº“æŸ¥æ‰¾ç”¨æˆ·
3. ä½¿ç”¨ bcrypt éªŒè¯å¯†ç 
4. ç”Ÿæˆ JWT token
5. è¿”å›ç”¨æˆ·ä¿¡æ¯

**å®ç°ä»£ç **ï¼š

```typescript
CredentialsProvider({
  name: 'credentials',
  credentials: {
    email: { label: 'Email', type: 'email' },
    password: { label: 'Password', type: 'password' },
  },
  async authorize(credentials) {
    if (!credentials?.email || !credentials?.password) {
      throw new Error('Invalid credentials');
    }

    // æŸ¥æ‰¾ç”¨æˆ·
    const user = await prisma.user.findUnique({
      where: { email: credentials.email },
    });

    if (!user || !user.password) {
      throw new Error('Invalid credentials');
    }

    // éªŒè¯å¯†ç 
    const isPasswordValid = await bcrypt.compare(
      credentials.password,
      user.password
    );

    if (!isPasswordValid) {
      throw new Error('Invalid credentials');
    }

    return {
      id: user.id,
      email: user.email,
      name: user.name,
      image: user.image,
    };
  },
});
```

### GitHub OAuth Providerï¼ˆå¯é€‰ï¼‰

**é…ç½®æ­¥éª¤**ï¼š

1. åœ¨ GitHub åˆ›å»º OAuth App
2. è·å– Client ID å’Œ Secret
3. é…ç½®ç¯å¢ƒå˜é‡
4. æ·»åŠ åˆ° providers

```typescript
GitHubProvider({
  clientId: process.env.GITHUB_ID!,
  clientSecret: process.env.GITHUB_SECRET!,
});
```

**GitHub OAuth App è®¾ç½®**ï¼š

- Homepage URL: `http://localhost:3000`
- Authorization callback URL: `http://localhost:3000/api/auth/callback/github`

## ğŸ“¦ æ•°æ®æ¨¡å‹

### User

```prisma
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  password      String?   // OAuth ç”¨æˆ·ä¸º null
  emailVerified DateTime?
  image         String?

  accounts      Account[]
  sessions      Session[]
}
```

### Accountï¼ˆOAuthï¼‰

```prisma
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  // ... å…¶ä»–å­—æ®µ
}
```

### Session

```prisma
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
}
```

## ğŸ” å¯†ç å®‰å…¨

### å¯†ç å“ˆå¸Œ

ä½¿ç”¨ **bcrypt** è¿›è¡Œå¯†ç å“ˆå¸Œï¼š

```typescript
import bcrypt from 'bcryptjs';

// æ³¨å†Œæ—¶å“ˆå¸Œå¯†ç 
const hashedPassword = await bcrypt.hash(password, 12);

// ç™»å½•æ—¶éªŒè¯å¯†ç 
const isValid = await bcrypt.compare(inputPassword, hashedPassword);
```

**Salt Rounds**: 12ï¼ˆå®‰å…¨ä¸”æ€§èƒ½å¹³è¡¡ï¼‰

### å¯†ç ç­–ç•¥

åœ¨ `src/utils/validators.ts` ä¸­å®šä¹‰ï¼š

```typescript
const registerSchema = z.object({
  email: z.string().email(),
  password: z
    .string()
    .min(8, 'å¯†ç è‡³å°‘8ä¸ªå­—ç¬¦')
    .max(100, 'å¯†ç å¤ªé•¿')
    .regex(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/,
      'å¯†ç å¿…é¡»åŒ…å«å¤§å†™ã€å°å†™å­—æ¯å’Œæ•°å­—'
    ),
});
```

**è¦æ±‚**ï¼š

- æœ€å°‘ 8 ä¸ªå­—ç¬¦
- è‡³å°‘ä¸€ä¸ªå¤§å†™å­—æ¯
- è‡³å°‘ä¸€ä¸ªå°å†™å­—æ¯
- è‡³å°‘ä¸€ä¸ªæ•°å­—

## ğŸ« Session ç®¡ç†

### JWT Strategy

ä½¿ç”¨ JWT è€Œéæ•°æ®åº“ sessionï¼š

```typescript
session: {
  strategy: 'jwt',
  maxAge: 30 * 24 * 60 * 60, // 30 å¤©
}
```

**ä¼˜ç‚¹**ï¼š

- æ— éœ€æ•°æ®åº“æŸ¥è¯¢
- å¯æ‰©å±•æ€§å¥½
- é€‚åˆæ— çŠ¶æ€åº”ç”¨

**ç¼ºç‚¹**ï¼š

- æ— æ³•ç«‹å³æ’¤é”€
- Token ä½“ç§¯è¾ƒå¤§

### Callbacks

#### JWT Callback

åœ¨ token ä¸­æ·»åŠ ç”¨æˆ· IDï¼š

```typescript
async jwt({ token, user }) {
  if (user) {
    token.id = user.id;
  }
  return token;
}
```

#### Session Callback

å°† token ä¿¡æ¯ä¼ é€’ç»™ sessionï¼š

```typescript
async session({ session, token }) {
  if (session.user) {
    session.user.id = token.id;
  }
  return session;
}
```

## ğŸ›¡ï¸ è®¤è¯è¾…åŠ©å‡½æ•°

ä½ç½®ï¼š`src/lib/auth-helpers.ts`

### getSession

è·å–å½“å‰ä¼šè¯ï¼š

```typescript
export async function getSession() {
  return await getServerSession(authOptions);
}
```

### getCurrentUser

è·å–å½“å‰ç”¨æˆ·æˆ–æŠ›å‡ºé”™è¯¯ï¼š

```typescript
export async function getCurrentUser() {
  const session = await getSession();

  if (!session?.user) {
    throw new AuthenticationError('Not authenticated');
  }

  return session.user;
}
```

### isAuthenticated

æ£€æŸ¥æ˜¯å¦å·²è®¤è¯ï¼š

```typescript
export async function isAuthenticated(): Promise<boolean> {
  const session = await getSession();
  return !!session?.user;
}
```

## ğŸŒ API è·¯ç”±

### NextAuth Route Handler

ä½ç½®ï¼š`app/api/auth/[...nextauth]/route.ts`

```typescript
import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
```

**å¤„ç†çš„ç«¯ç‚¹**ï¼š

- `/api/auth/signin` - ç™»å½•
- `/api/auth/signout` - ç™»å‡º
- `/api/auth/session` - è·å– session
- `/api/auth/callback/*` - OAuth å›è°ƒ

### æ³¨å†Œç«¯ç‚¹

ä½ç½®ï¼š`app/api/register/route.ts`

```typescript
export async function POST(req: NextRequest) {
  // 1. éªŒè¯è¾“å…¥
  const validation = registerSchema.safeParse(body);

  // 2. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨
  const existingUser = await prisma.user.findUnique({
    where: { email },
  });

  // 3. å“ˆå¸Œå¯†ç 
  const hashedPassword = await bcrypt.hash(password, 12);

  // 4. åˆ›å»ºç”¨æˆ·
  const user = await prisma.user.create({
    data: { email, password: hashedPassword, name },
  });

  return NextResponse.json({ success: true, data: user });
}
```

## ğŸ¨ å®¢æˆ·ç«¯ä½¿ç”¨

### ç™»å½•

```typescript
import { signIn } from 'next-auth/react';

const handleLogin = async (email: string, password: string) => {
  const result = await signIn('credentials', {
    email,
    password,
    redirect: false,
  });

  if (result?.error) {
    console.error('Login failed');
  } else {
    router.push('/dashboard');
  }
};
```

### ç™»å‡º

```typescript
import { signOut } from 'next-auth/react';

const handleLogout = () => {
  signOut({ callbackUrl: '/' });
};
```

### è·å– Session

```typescript
import { useSession } from 'next-auth/react';

function MyComponent() {
  const { data: session, status } = useSession();

  if (status === 'loading') return <div>Loading...</div>;
  if (status === 'unauthenticated') return <div>Please login</div>;

  return <div>Welcome, {session.user.email}</div>;
}
```

## ğŸ”’ ä¿æŠ¤è·¯ç”±

### æœåŠ¡ç«¯ç»„ä»¶

```typescript
// app/dashboard/page.tsx
import { getCurrentUser } from '@/lib/auth-helpers';
import { redirect } from 'next/navigation';

export default async function DashboardPage() {
  try {
    const user = await getCurrentUser();
  } catch {
    redirect('/login');
  }

  return <div>Dashboard</div>;
}
```

### API è·¯ç”±

```typescript
// app/api/protected/route.ts
import { getCurrentUser } from '@/lib/auth-helpers';

export async function GET() {
  try {
    const user = await getCurrentUser();
    // å¤„ç†è¯·æ±‚
  } catch {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
}
```

### å®¢æˆ·ç«¯ç»„ä»¶

```typescript
'use client';

import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { useEffect } from 'react';

export function ProtectedComponent() {
  const { status } = useSession();
  const router = useRouter();

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/login');
    }
  }, [status, router]);

  if (status === 'loading') return <div>Loading...</div>;

  return <div>Protected content</div>;
}
```

## ğŸ”§ ç¯å¢ƒå˜é‡

å¿…éœ€çš„ç¯å¢ƒå˜é‡ï¼š

```env
# NextAuth
NEXTAUTH_URL="http://localhost:3000"
NEXTAUTH_SECRET="your-secret-here"

# GitHub OAuthï¼ˆå¯é€‰ï¼‰
GITHUB_ID="your-github-client-id"
GITHUB_SECRET="your-github-client-secret"
```

## ğŸš¨ å®‰å…¨æœ€ä½³å®è·µ

### 1. ä½¿ç”¨å¼ºå¯†é’¥

```bash
openssl rand -base64 32
```

### 2. HTTPS Onlyï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰

```typescript
// next.config.js
async headers() {
  return [
    {
      headers: [
        {
          key: 'Strict-Transport-Security',
          value: 'max-age=63072000; includeSubDomains; preload',
        },
      ],
    },
  ];
}
```

### 3. CSRF ä¿æŠ¤

NextAuth è‡ªåŠ¨å¯ç”¨ CSRF tokenã€‚

### 4. é€Ÿç‡é™åˆ¶

```typescript
import { RateLimitError } from '@/utils/errors';

// ç™»å½•é€Ÿç‡é™åˆ¶ï¼ˆå»ºè®®ä½¿ç”¨ Redisï¼‰
const loginAttempts = new Map();

export async function checkRateLimit(email: string) {
  const attempts = loginAttempts.get(email) || 0;

  if (attempts > 5) {
    throw new RateLimitError('Too many login attempts');
  }

  loginAttempts.set(email, attempts + 1);
}
```

## ğŸ“Š Session ç”Ÿå‘½å‘¨æœŸ

```
1. ç”¨æˆ·ç™»å½•
   â†“
2. NextAuth ç”Ÿæˆ JWT
   â†“
3. JWT å­˜å‚¨åœ¨ HTTP-only Cookie
   â†“
4. æ¯æ¬¡è¯·æ±‚è‡ªåŠ¨å‘é€ Cookie
   â†“
5. NextAuth éªŒè¯ JWT
   â†“
6. æä¾› session æ•°æ®ç»™åº”ç”¨
   â†“
7. ç”¨æˆ·ç™»å‡º â†’ åˆ é™¤ Cookie
```

## ğŸ”„ åˆ·æ–° Session

```typescript
// å®¢æˆ·ç«¯åˆ·æ–° session
import { useSession } from 'next-auth/react';

const { update } = useSession();

// æ›´æ–° session
await update({
  name: 'New Name',
});
```

## ğŸ§ª æµ‹è¯•

### æµ‹è¯•ç™»å½•

```typescript
import { signIn } from 'next-auth/react';

// Mock signIn
jest.mock('next-auth/react');

test('login with valid credentials', async () => {
  (signIn as jest.Mock).mockResolvedValue({ error: null });

  await handleLogin('test@example.com', 'password');

  expect(signIn).toHaveBeenCalledWith('credentials', {
    email: 'test@example.com',
    password: 'password',
    redirect: false,
  });
});
```

---

**æœ€åæ›´æ–°**: 2025-01-15
**ç»´æŠ¤è€…**: é¡¹ç›®å›¢é˜Ÿ
